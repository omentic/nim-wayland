##  Copyright © 2008 Kristian Høgsberg
##
##  Permission is hereby granted, free of charge, to any person obtaining
##  a copy of this software and associated documentation files (the
##  "Software"), to deal in the Software without restriction, including
##  without limitation the rights to use, copy, modify, merge, publish,
##  distribute, sublicense, and/or sell copies of the Software, and to
##  permit persons to whom the Software is furnished to do so, subject to
##  the following conditions:
##
##  The above copyright notice and this permission notice (including the
##  next paragraph) shall be included in all copies or substantial
##  portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
##  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
##  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
##  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
##  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
##  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
##  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
##  SOFTWARE.

import util, version

##  \class wl_proxy
##
##  \brief Represents a protocol object on the client side.
##
##  A wl_proxy acts as a client side proxy to an object existing in the
##  compositor. The proxy is responsible for converting requests made by the
##  clients with \ref wl_proxy_marshal() into Wayland's wire format. Events
##  coming from the compositor are also handled by the proxy, which will in
##  turn call the handler set with \ref wl_proxy_add_listener().
##
##  \note With the exception of function \ref wl_proxy_set_queue(), functions
##  accessing a wl_proxy are not normally used by client code. Clients
##  should normally use the higher level interface generated by the scanner to
##  interact with compositor objects.
type WlProxy* = object # FIXME

##  \class wl_display
##
##  \brief Represents a connection to the compositor and acts as a proxy to
##  the wl_display singleton object.
##
##  A wl_display object represents a client connection to a Wayland
##  compositor. It is created with either \ref wl_display_connect() or
##  \ref wl_display_connect_to_fd(). A connection is terminated using
##  \ref wl_display_disconnect().
##
##  A wl_display is also used as the \ref wl_proxy for the wl_display
##  singleton object on the compositor side.
##
##  A wl_display object handles all the data sent from and to the
##  compositor. When a \ref wl_proxy marshals a request, it will write its wire
##  representation to the display's write buffer. The data is sent to the
##  compositor when the client calls \ref wl_display_flush().
##
##  Incoming data is handled in two steps: queueing and dispatching. In the
##  queue step, the data coming from the display fd is interpreted and
##  added to a queue. On the dispatch step, the handler for the incoming
##  event set by the client on the corresponding \ref wl_proxy is called.
##
##  A wl_display has at least one event queue, called the <em>default
##  queue</em>. Clients can create additional event queues with \ref
##  wl_display_create_queue() and assign \ref wl_proxy's to it. Events
##  occurring in a particular proxy are always queued in its assigned queue.
##  A client can ensure that a certain assumption, such as holding a lock
##  or running from a given thread, is true when a proxy event handler is
##  called by assigning that proxy to an event queue and making sure that
##  this queue is only dispatched when the assumption holds.
##
##  The default queue is dispatched by calling \ref wl_display_dispatch().
##  This will dispatch any events queued on the default queue and attempt
##  to read from the display fd if it's empty. Events read are then queued
##  on the appropriate queues according to the proxy assignment.
##
##  A user created queue is dispatched with \ref wl_display_dispatch_queue().
##  This function behaves exactly the same as wl_display_dispatch()
##  but it dispatches given queue instead of the default queue.
##
##  A real world example of event queue usage is Mesa's implementation of
##  eglSwapBuffers() for the Wayland platform. This function might need
##  to block until a frame callback is received, but dispatching the default
##  queue could cause an event handler on the client to start drawing
##  again. This problem is solved using another event queue, so that only
##  the events handled by the EGL code are dispatched during the block.
##
##  This creates a problem where a thread dispatches a non-default
##  queue, reading all the data from the display fd. If the application
##  would call \em poll(2) after that it would block, even though there
##  might be events queued on the default queue. Those events should be
##  dispatched with \ref wl_display_dispatch_pending() or \ref
##  wl_display_dispatch_queue_pending() before flushing and blocking.
type WlDisplay* = object # FIXME

##  \class wl_event_queue
##
##  \brief A queue for \ref wl_proxy object events.
##
##  Event queues allows the events on a display to be handled in a thread-safe
##  manner. See \ref wl_display for details.
type WlEventQueue* = object # FIXME


##  Destroy proxy after marshalling
##  @ingroup WlProxy
const WL_MARSHAL_FLAG_DESTROY* = (1 shl 0)

proc destroy*(queue: ptr WlEventQueue) {.importc: "wl_event_queue_destroy".}

proc marshalFlags*(proxy: ptr WlProxy; opcode: uint32; `interface`: ptr WlInterface; version: uint32; flags: uint32): ptr WlProxy {.varargs, importc: "wl_proxy_marshal_flags".}
proc marshalArrayFlags*(proxy: ptr WlProxy; opcode: uint32; `interface`: ptr WlInterface; version: uint32; flags: uint32; args: ptr WlArgument): ptr WlProxy {.importc: "wl_proxy_marshal_array_flags".}
proc marshal*(p: ptr WlProxy; opcode: uint32) {.varargs,importc: "wl_proxy_marshal".}
proc marshalArray*(p: ptr WlProxy; opcode: uint32; args: ptr WlArgument) {.importc: "wl_proxy_marshal_array".}

proc createWlProxy*(factory: ptr WlProxy; `interface`: ptr WlInterface): ptr WlProxy {.importc: "wl_proxy_create".}
proc createWlProxyWrapper*(proxy: pointer): pointer {.importc: "wl_proxy_create_wrapper".}
proc destroyWlProxyWrapper*(proxy_wrapper: pointer) {.importc: "wl_proxy_wrapper_destroy".}

proc marshalConstructor*(proxy: ptr WlProxy; opcode: uint32; `interface`: ptr WlInterface): ptr WlProxy {.varargs, importc: "wl_proxy_marshal_constructor".}
proc marshalConstructorVersioned*(proxy: ptr WlProxy; opcode: uint32; `interface`: ptr WlInterface; version: uint32): ptr WlProxy {.varargs,importc: "wl_proxy_marshal_constructor_versioned".}
proc marshalArrayConstructor*(proxy: ptr WlProxy; opcode: uint32; args: ptr WlArgument; `interface`: ptr WlInterface): ptr WlProxy {.importc: "wl_proxy_marshal_array_constructor".}
proc marshalArrayConstructorVersioned*(proxy: ptr WlProxy; opcode: uint32; args: ptr WlArgument; `interface`: ptr WlInterface; version: uint32): ptr WlProxy {.importc: "wl_proxy_marshal_array_constructor_versioned".}

proc destroy*(proxy: ptr WlProxy) {.importc: "wl_proxy_destroy".}
proc addListener*(proxy: ptr WlProxy; implementation: proc () {.cdecl.}; data: pointer): cint {.importc: "wl_proxy_add_listener".}
proc getListener*(proxy: ptr WlProxy): pointer {.importc: "wl_proxy_get_listener".}
proc addDispatcher*(proxy: ptr WlProxy; dispatcher_func: WlDispatcherFunc; dispatcher_data: pointer; data: pointer): cint {.importc: "wl_proxy_add_dispatcher".}
proc setUserData*(proxy: ptr WlProxy; user_data: pointer) {.importc: "wl_proxy_set_user_data".}
proc getUserData*(proxy: ptr WlProxy): pointer {.importc: "wl_proxy_get_user_data".}
proc getVersion*(proxy: ptr WlProxy): uint32 {.importc: "wl_proxy_get_version".}
proc getId*(proxy: ptr WlProxy): uint32 {.importc: "wl_proxy_get_id".}
proc setTag*(proxy: ptr WlProxy; tag: cstringArray) {.importc: "wl_proxy_set_tag".}
proc getTag*(proxy: ptr WlProxy): cstringArray {.importc: "wl_proxy_get_tag".}
proc getClass*(proxy: ptr WlProxy): cstring {.importc: "wl_proxy_get_class".}
proc setQueue*(proxy: ptr WlProxy; queue: ptr WlEventQueue) {.importc: "wl_proxy_set_queue".}

proc connect*(name: cstring): ptr WlDisplay {.importc: "wl_display_connect".}
proc connectToFd*(fd: cint): ptr WlDisplay {.importc: "wl_display_connect_to_fd".}
proc disconnect*(display: ptr WlDisplay) {.importc: "wl_display_disconnect".}
proc getFd*(display: ptr WlDisplay): cint {.importc: "wl_display_get_fd".}

proc dispatch*(display: ptr WlDisplay): cint {.importc: "wl_display_dispatch".}
proc dispatch_queue*(display: ptr WlDisplay; queue: ptr WlEventQueue): cint {.importc: "wl_display_dispatch_queue".}
proc dispatch_queue_pending*(display: ptr WlDisplay; queue: ptr WlEventQueue): cint {.importc: "wl_display_dispatch_queue_pending".}
proc dispatch_pending*(display: ptr WlDisplay): cint {.importc: "wl_display_dispatch_pending".}

proc getError*(display: ptr WlDisplay): cint {.importc: "wl_display_get_error".}
proc getProtocolError*(display: ptr WlDisplay; `interface`: ptr ptr WlInterface; id: ptr uint32): uint32 {.importc: "wl_display_get_protocol_error".}

proc flush*(display: ptr WlDisplay): cint {.importc: "wl_display_flush".}

proc roundtripQueue*(display: ptr WlDisplay; queue: ptr WlEventQueue): cint {.importc: "wl_display_roundtrip_queue".}
proc roundtrip*(display: ptr WlDisplay): cint {.importc: "wl_display_roundtrip".}

proc createQueue*(display: ptr WlDisplay): ptr WlEventQueue {.importc: "wl_display_create_queue".}
proc prepareReadQueue*(display: ptr WlDisplay; queue: ptr WlEventQueue): cint {.importc: "wl_display_prepare_read_queue".}
proc prepareRead*(display: ptr WlDisplay): cint {.importc: "wl_display_prepare_read".}
proc cancelRead*(display: ptr WlDisplay) {.importc: "wl_display_cancel_read".}
proc readEvents*(display: ptr WlDisplay): cint {.importc: "wl_display_read_events".}

proc setHandlerClient*(handler: WlLogFunc) {.importc: "wl_log_set_handler_client".}
